'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/go/',title:"Go",content:"Go 特徴  Google によって開発されたオープンソースのプログラミング言語． 強い静的型付け，コンパイル言語，メモリ安全性，ガーベージコレクションなどの特徴がある． プログラマーの生産性を向上されるために，シンプルで効率的なコーディングを行えるように設計されている． 非同期処理をシンプルに書きつつマルチコア性能を引き出せるように設計されている． GitHub: https://github.com/golang Webpage: https://go.dev WebPage: https://golang.org  勉強する順番  Go Tour をやる．   英語  日本語   Effective Go を読む．   英語   GitHub から興味のあるソースを読む． 標準ライブラリを読む． 動くコードで「車輪の再発明」をやってみる． 間に適宜スキルにあった書籍を読む．  "}),a.add({id:1,href:'/docs/go/closure/',title:"Closure",content:"closure とは  関数オブジェクトの1つ． 引数以外の変数を実行時の環境ではなく，closure が定義されている環境（静的スコープ）において解決することを特徴とする．  closure のメリット  closure を高階関数の引数に渡して，記述の簡素化や高階関数の外側の状態の参照が可能になる． closure は遅延評価される（呼び出されるまで何も実行しない）ので，制御構造の定義に用いることができる．  Go の関数は closure  closure は closure 自身の外部から変数を参照する関数値のことであり， closure は参照された変数へアクセスして変えることができる． その意味で，closure はその変数へ bind されている．  Go における closure としての無名関数の特徴  closure から参照されたローカル変数は，関数内のローカル変数とは別物になりclosure の変数になる． closure が何らかの形で参照される限り closure の変数も破棄されない．  "}),a.add({id:2,href:'/docs/go/declaration/',title:"Declaration",content:"Declaration Syntax 公式による解説ブログ   Go\u0026rsquo;s Declaration Syntax 上記の日本語訳: Go\u0026rsquo;s Declaration Syntaxのゆるーい和訳  "}),a.add({id:3,href:'/docs/go/interface/',title:"Interface",content:"interface  method の一覧を定義する型． 型に method を実装することによって，interface を実装する． interface を明示的に宣言する必要はない． この定義と実装を切り離していることを暗黙のインターフェースという．  interface をこのような実装にした理由の1つは，同じインターフェースを実装する異なる構造体を，新たな型として定義できるから．    interface value  インターフェースの値は，下のような値と具体的な型のタプルのように考えることができる． (value, type)  インターフェースの値は，特定の基底になる具体的な型の値を保持する． インターフェースの値のメソッドを呼び出すと，その基底型の同じ名前のメソッドが実行される． インターフェース自体の中にある具体的な値が nil の場合，メソッドは nil をレシーバーとして呼び出される．  具体的な値として nil を保持するインターフェースの値それ自体は非 nil である．    nil interface  nil interface の値は，値も具体的な型も保持しない．  nil interface には呼び出す具体的なメソッドを示す型がタプル内に存在しないため，nil interface のメソッドを呼び出すと，ランタイムエラーになる．    empty interface  empty interface は0個のメソッドを指定されたインターフェースのこと． empty interface は，任意のかたの値を保持できる． 全ての型は，少なくとも0個のメソッドを実装している．  type assertion  type assersion は，interface の値の基になる具体的な値を利用する手段を提供する． t := i.(T)  上の文は，interface の値 i が具体的な型 T を保持し，基になる型 T の値を変数 t に代入することを主張する． i が T を保持していない場合，上の文は panic を引き起こす．   interface の値が特定の型を保持しているかどうかをテストするために，type assersion は2つの値を返すことができる．  2つの値とは，基になる値とアサーションが成功したかどうかを報告するブール値．  t, ok := i.(T)  i が T を保持していれば，t は基になる値になり，ok は true になる． そうでなければ，t は型 T のゼロ値になり，ok は false になる．この時は panic は起きない．    type switch  type switch はいくつかの type assersion を直列に使用できる構造になっている． type swithc の case は型を指定し，type switch の値は指定された interface の値が保持する値の型と比較される．  "}),a.add({id:4,href:'/docs/go/slice/',title:"Slice",content:"slice  可変長配列を持たない代わりに実装された型． 配列全体のポインタ（ptr），配列の長さ（len），配列の容量（cap）を保持するデータ構造． 配列の部分列を簡単に取り出せる．  公式による解説ブログ   Go Slices: usage and internals  slice と array の定義 slice の定義 test := []int{1, 2, 3} //要素数3 容量3の slice test := make([]int, 3, 3) //要素数3 要素数3の slice array の定義 var test[] //要素数0 容量0の array var test[10] //要素数10 容量10の array test := [3]int{1, 2, 3} //要素数3 容量3の array test := [...]int{1, 2, 3} //要素数3 容量3の array  Reference: Go言語のスライスで勘違いしやすいこところ  "}),a.add({id:5,href:'/docs/go/vim-go/',title:"Vim Go",content:"vim-go  vim 用の Go 開発プラグイン GitHub: fatih/vim-go  日本語訳  GitHub: hnakamur/vim-go-tutorial-ja  "}),a.add({id:6,href:'/docs/',title:"Docs",content:""}),a.add({id:7,href:'/docs/go/method-receiver/',title:"method \u0026 receiver",content:"method  Go には class が無い． その代わりに，receiver を用いて type に method を定義する．  receiver  receiver は，func キーワードと method の間に引数リストをとる． receiver には，変数レシーバーとポインターレシーバーがある． 変数レシーバーは元の変数のコピーを操作する． ポインターレシーバーは元の変数を変更する．  pointer reciever  メソッドがポインターレシーバーの場合，呼び出し時に，変数またはポインタのいずれかをレシーバーとして取ることができる．  ポインターレシーバーが引数に変数を受け取るとポインターとして解釈してくれる． 利便性のために．   ポインタレシーバーを使う理由は  メソッドがレシーバーが指す先の変数を変更するため． メソッドの呼び出し毎に変数のコピーを避けるため．    "})})()